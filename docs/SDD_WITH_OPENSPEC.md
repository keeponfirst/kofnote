# Spec-Driven Development with OpenSpec

Updated: 2026-02-09

## 1. Why OpenSpec in this project

KOF Note has grown into a multi-surface desktop product (records/logs/AI/integrations, plus Rust + React runtime).  
OpenSpec is introduced as the **single source of truth (SSOT)** for changes so implementation, testing, and review are driven by explicit artifacts instead of chat/context memory.

Problems this solves:

- Reduces requirement drift across frontend/backend/integration changes.
- Makes acceptance criteria explicit before coding.
- Improves handoff between architecture/design/implementation/testing.
- Creates a repeatable change history under version control.

## 2. Prerequisites and initialization

OpenSpec requires Node.js `20.19+`.

Recommended setup commands:

```bash
npm install -g @fission-ai/openspec@latest
cd /Users/pershing/Documents/henry/Fun/kofnote
openspec init
```

Optional telemetry opt-out:

```bash
export OPENSPEC_TELEMETRY=0
```

In restricted/offline environments, setting this avoids telemetry flush warnings during CLI runs.

## 3. OpenSpec structure used in this repo

Current initialized structure:

```text
openspec/
├── config.yaml              # workflow schema config (currently: spec-driven)
├── specs/                   # baseline/domain specs (long-lived)
└── changes/                 # per-change working artifacts
    └── archive/             # archived/completed changes
```

Codex integration artifacts generated by init:

```text
.codex/skills/openspec-*
```

## 4. Recommended spec/change layout

### Baseline specs (stable requirements)

Use `openspec/specs/` for domain-level specs that should outlive a single ticket/change.

Example pattern:

```text
openspec/specs/<capability>/spec.md
```

### Change artifacts (work in progress)

For each change, create a folder under `openspec/changes/<change-id>/` and progress artifacts by schema order (spec-driven).

Typical artifacts in spec-driven workflow:

- `proposal.md`
- `specs/<capability>/spec.md` (delta spec per capability)
- `design.md`
- `tasks.md`

Use OpenSpec CLI status/instructions as source of truth when schema output differs:

```bash
openspec status --change "<change-id>"
openspec instructions <artifact> --change "<change-id>"
openspec instructions apply --change "<change-id>"
```

## 5. Team workflow (proposal -> spec -> tasks -> implement -> verify)

1. **Create change**
   - `openspec new change "<change-id>"`
2. **Draft artifacts in order**
   - use `openspec status --change "<change-id>"`
   - use `openspec instructions <artifact> --change "<change-id>"`
3. **Implement from tasks**
   - use `openspec instructions apply --change "<change-id>"`
   - code only after tasks are explicit.
4. **Verify and reconcile**
   - check artifact/code consistency before merge/archive.
5. **Archive completed change**
   - move completed change to `openspec/changes/archive/` via OpenSpec workflow/commands.

## 6. Governance rules for this repository

For any new feature or behavior change:

1. Write spec first (no direct implementation without spec).
2. Spec must include:
   - Acceptance criteria.
   - Non-functional requirements.
   - Risks.
   - Rollback strategy.
3. Tasks must be traceable to requirements (1 requirement -> 1+ tasks).
4. Implementation PR/commit message should reference corresponding OpenSpec change ID.
5. If implementation diverges, update spec/design/tasks first, then code.

## 7. Suggested command cheat sheet

```bash
# list and inspect
openspec list
openspec status --change "<change-id>"

# start and continue
openspec new change "<change-id>"
openspec instructions <artifact> --change "<change-id>"

# implementation phase
openspec instructions apply --change "<change-id>"
```

## 8. Example reference

A minimal example baseline spec is provided at:

- `openspec/specs/example/spec.md`

Use this as a template when creating new capability specs.
